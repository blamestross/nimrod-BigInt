/* Generated by Nimrod Compiler v0.9.4 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   "C:\Program Files (x86)\Nimrod\dist\mingw\bin\gcc.exe" -c  -w  -I"C:\Program Files (x86)\Nimrod\lib" -o c:\users\brnedan\documents\github\nimrod-bigint\nimcache\bigint.o c:\users\brnedan\documents\github\nimrod-bigint\nimcache\bigint.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <stdio.h>

#include <string.h>
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct bigint84006 bigint84006;
typedef struct bigintdigits84004 bigintdigits84004;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  bigint84006  {
bigintdigits84004* Digits;
NIM_BOOL Neg;
};
typedef N_NIMCALL_PTR(void, TY2289) (void* p, NI op);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2289 marker;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
typedef NU32 TY84037[1];
struct bigintdigits84004 {
  TGenericSeq Sup;
  NU32 data[SEQ_DECL_SIZE];
};
N_NIMCALL(NimStringDesc*, nimInt64ToStr)(NI64 x);
N_NIMCALL(void, initbigint_84017)(NU32 val, bigint84006* Result);
N_NIMCALL(void, TMP125)(void* p, NI op);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(void, genericSeqAssign)(void* dest, void* src_76004, TNimType* mt);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
N_NIMCALL(void, invert_84042)(bigint84006 a, bigint84006* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
static N_INLINE(NI, subInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(NI64, mulInt64)(NI64 a, NI64 b);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(void, HEX2D_84106)(bigint84006 a, bigint84006 b, bigint84006* Result);
static N_INLINE(NI64, subInt64)(NI64 a, NI64 b);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NIMCALL(void, HEX2B_84233)(bigint84006 a, bigint84006 b, bigint84006* Result);
static N_INLINE(NI64, addInt64)(NI64 a, NI64 b);
N_NIMCALL(NimStringDesc*, HEX24_84358)(bigintdigits84004* x_84364);
N_NIMCALL(NimStringDesc*, collectiontostring_84368)(bigintdigits84004* x_84372, NimStringDesc* b_84374, NimStringDesc* e_84376);
static N_INLINE(void, initStackBottom)(void);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
N_NOINLINE(void, systemInit)(void);
N_NOINLINE(void, systemDatInit)(void);
N_NOINLINE(void, bigintInit)(void);
N_NOINLINE(void, bigintDatInit)(void);
NI64 maxint_84011;
extern TNimType NTI122; /* uint32 */
TNimType NTI84004; /* BigIntDigits */
extern TFrame* frameptr_13038;
TNimType NTI84006; /* BigInt */
extern TNimType NTI134; /* bool */
bigint84006 a_84347;
bigint84006 b_84350;
bigint84006 c_84353;
N_NIMCALL(void, TMP125)(void* p, NI op) {
	bigintdigits84004* a;
	NI LOC1;
	a = (bigintdigits84004*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_13038;
	frameptr_13038 = s;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_13038 = (*frameptr_13038).prev;
}

N_NIMCALL(void, initbigint_84017)(NU32 val, bigint84006* Result) {
	bigintdigits84004* LOC1;
	TY84037 LOC2;
	nimfr("initBigInt", "bigint.nim")
	nimln(13, "bigint.nim");
	nimln(13, "bigint.nim");
	LOC1 = 0;
	LOC1 = (bigintdigits84004*) newSeq((&NTI84004), 1);
	LOC2[0] = val;
	LOC1->data[0] = LOC2[0];
	genericSeqAssign(&(*Result).Digits, ((bigintdigits84004*) (LOC1)), (&NTI84004));
	nimln(14, "bigint.nim");
	(*Result).Neg = NIM_FALSE;
	popFrame();
}

static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, invert_84042)(bigint84006 a, bigint84006* Result) {
	bigintdigits84004* digits;
	NI i;
	NI TMP127;
	nimfr("invert", "bigint.nim")
	nimln(18, "bigint.nim");
	chckNil((void*)Result);
	genericReset((void*)Result, (&NTI84006));
	initbigint_84017(((NU32) 0), Result);
	nimln(19, "bigint.nim");
	nimln(19, "bigint.nim");
	(*Result).Neg = !((*Result).Neg);
	nimln(20, "bigint.nim");
	digits = (bigintdigits84004*) newSeq((&NTI84004), 0);
	nimln(21, "bigint.nim");
	nimln(21, "bigint.nim");
	nimln(21, "bigint.nim");
	TMP127 = subInt(a.Digits->Sup.len, 1);
	i = (NI64)(TMP127);
	nimln(22, "bigint.nim");
	while (1) {
		NI64 tmp;
		NI64 TMP128;
		NI TMP129;
		nimln(22, "bigint.nim");
		if (!(0 <= i)) goto LA1;
		nimln(23, "bigint.nim");
		if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
		tmp = ((NI64) (a.Digits->data[i]));
		nimln(24, "bigint.nim");
		nimln(24, "bigint.nim");
		TMP128 = mulInt64(tmp, -1);
		tmp = (NI64)(TMP128);
		nimln(25, "bigint.nim");
		digits = (bigintdigits84004*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (tmp));
		nimln(26, "bigint.nim");
		nimln(26, "bigint.nim");
		TMP129 = subInt(i, 1);
		i = (NI64)(TMP129);
	} LA1: ;
	nimln(27, "bigint.nim");
	genericSeqAssign(&(*Result).Digits, digits, (&NTI84004));
	popFrame();
}

static N_INLINE(NI64, subInt64)(NI64 a, NI64 b) {
	NI64 result;
	result = 0;
	result = (NI64)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI64)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI64)(result ^ (NI64)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, HEX2D_84106)(bigint84006 a, bigint84006 b, bigint84006* Result) {
	bigintdigits84004* digits;
	NI i;
	NI64 carry;
	nimfr("-", "bigint.nim")
	nimln(31, "bigint.nim");
	chckNil((void*)Result);
	genericReset((void*)Result, (&NTI84006));
	initbigint_84017(((NU32) 0), Result);
	nimln(32, "bigint.nim");
	digits = (bigintdigits84004*) newSeq((&NTI84004), 0);
	nimln(33, "bigint.nim");
	i = 0;
	nimln(34, "bigint.nim");
	carry = 0;
	nimln(35, "bigint.nim");
	while (1) {
		NIM_BOOL LOC2;
		NI64 tmp;
		NI TMP137;
		nimln(35, "bigint.nim");
		LOC2 = 0;
		nimln(35, "bigint.nim");
		nimln(35, "bigint.nim");
		LOC2 = (i < a.Digits->Sup.len);
		if (LOC2) goto LA3;
		nimln(35, "bigint.nim");
		nimln(35, "bigint.nim");
		LOC2 = (i < b.Digits->Sup.len);
		LA3: ;
		if (!LOC2) goto LA1;
		tmp = 0;
		nimln(37, "bigint.nim");
		{
			nimln(37, "bigint.nim");
			nimln(37, "bigint.nim");
			if (!(i < a.Digits->Sup.len)) goto LA6;
			nimln(38, "bigint.nim");
			{
				NI64 TMP130;
				NI64 TMP131;
				nimln(38, "bigint.nim");
				nimln(38, "bigint.nim");
				if (!(i < b.Digits->Sup.len)) goto LA10;
				nimln(39, "bigint.nim");
				nimln(39, "bigint.nim");
				nimln(39, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
				TMP130 = subInt64(((NI64) (a.Digits->data[i])), ((NI64) (b.Digits->data[i])));
				TMP131 = subInt64((NI64)(TMP130), carry);
				tmp = (NI64)(TMP131);
				nimln(40, "bigint.nim");
				{
					NI64 TMP132;
					nimln(40, "bigint.nim");
					if (!(maxint_84011 <= tmp)) goto LA14;
					nimln(41, "bigint.nim");
					carry = 1;
					nimln(42, "bigint.nim");
					nimln(42, "bigint.nim");
					TMP132 = subInt64(tmp, maxint_84011);
					tmp = (NI64)(TMP132);
				}
				goto LA12;
				LA14: ;
				{
					nimln(44, "bigint.nim");
					carry = 0;
				}
				LA12: ;
			}
			goto LA8;
			LA10: ;
			{
				NI64 TMP133;
				nimln(46, "bigint.nim");
				nimln(46, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				TMP133 = subInt64(((NI64) (a.Digits->data[i])), carry);
				tmp = (NI64)(TMP133);
				nimln(47, "bigint.nim");
				{
					NI64 TMP134;
					nimln(47, "bigint.nim");
					if (!(maxint_84011 <= tmp)) goto LA20;
					nimln(48, "bigint.nim");
					carry = 1;
					nimln(49, "bigint.nim");
					nimln(49, "bigint.nim");
					TMP134 = subInt64(tmp, maxint_84011);
					tmp = (NI64)(TMP134);
				}
				goto LA18;
				LA20: ;
				{
					nimln(51, "bigint.nim");
					carry = 0;
				}
				LA18: ;
			}
			LA8: ;
		}
		goto LA4;
		LA6: ;
		{
			NI64 TMP135;
			nimln(53, "bigint.nim");
			nimln(53, "bigint.nim");
			if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
			TMP135 = subInt64(((NI64) (((NI) (b.Digits->data[i])))), carry);
			tmp = (NI64)(TMP135);
			nimln(54, "bigint.nim");
			{
				NI64 TMP136;
				nimln(54, "bigint.nim");
				if (!(maxint_84011 <= tmp)) goto LA26;
				nimln(55, "bigint.nim");
				carry = 1;
				nimln(56, "bigint.nim");
				nimln(56, "bigint.nim");
				TMP136 = subInt64(tmp, maxint_84011);
				tmp = (NI64)(TMP136);
			}
			goto LA24;
			LA26: ;
			{
				nimln(58, "bigint.nim");
				carry = 0;
			}
			LA24: ;
		}
		LA4: ;
		nimln(59, "bigint.nim");
		digits = (bigintdigits84004*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (tmp));
		nimln(60, "bigint.nim");
		nimln(60, "bigint.nim");
		TMP137 = addInt(i, 1);
		i = (NI64)(TMP137);
	} LA1: ;
	nimln(61, "bigint.nim");
	{
		nimln(61, "bigint.nim");
		if (!(0 < carry)) goto LA31;
		nimln(62, "bigint.nim");
		digits = (bigintdigits84004*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (carry));
	}
	LA31: ;
	nimln(63, "bigint.nim");
	genericSeqAssign(&(*Result).Digits, digits, (&NTI84004));
	popFrame();
}

static N_INLINE(NI64, addInt64)(NI64 a, NI64 b) {
	NI64 result;
	result = 0;
	result = (NI64)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI64)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI64)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, HEX2B_84233)(bigint84006 a, bigint84006 b, bigint84006* Result) {
	bigintdigits84004* digits;
	NI i;
	NI64 carry;
	nimfr("+", "bigint.nim")
	nimln(67, "bigint.nim");
	chckNil((void*)Result);
	genericReset((void*)Result, (&NTI84006));
	initbigint_84017(((NU32) 0), Result);
	nimln(68, "bigint.nim");
	digits = (bigintdigits84004*) newSeq((&NTI84004), 0);
	nimln(69, "bigint.nim");
	i = 0;
	nimln(70, "bigint.nim");
	carry = 0;
	nimln(71, "bigint.nim");
	while (1) {
		NIM_BOOL LOC2;
		NI64 tmp;
		NI TMP145;
		nimln(71, "bigint.nim");
		LOC2 = 0;
		nimln(71, "bigint.nim");
		nimln(71, "bigint.nim");
		LOC2 = (i < a.Digits->Sup.len);
		if (LOC2) goto LA3;
		nimln(71, "bigint.nim");
		nimln(71, "bigint.nim");
		LOC2 = (i < b.Digits->Sup.len);
		LA3: ;
		if (!LOC2) goto LA1;
		tmp = 0;
		nimln(73, "bigint.nim");
		{
			nimln(73, "bigint.nim");
			nimln(73, "bigint.nim");
			if (!(i < a.Digits->Sup.len)) goto LA6;
			nimln(74, "bigint.nim");
			{
				NI64 TMP138;
				NI64 TMP139;
				nimln(74, "bigint.nim");
				nimln(74, "bigint.nim");
				if (!(i < b.Digits->Sup.len)) goto LA10;
				nimln(75, "bigint.nim");
				nimln(75, "bigint.nim");
				nimln(75, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
				TMP138 = addInt64(((NI64) (a.Digits->data[i])), ((NI64) (b.Digits->data[i])));
				TMP139 = addInt64((NI64)(TMP138), carry);
				tmp = (NI64)(TMP139);
				nimln(76, "bigint.nim");
				{
					NI64 TMP140;
					nimln(76, "bigint.nim");
					if (!(tmp < 0)) goto LA14;
					nimln(77, "bigint.nim");
					carry = 1;
					nimln(78, "bigint.nim");
					nimln(78, "bigint.nim");
					TMP140 = addInt64(tmp, maxint_84011);
					tmp = (NI64)(TMP140);
				}
				goto LA12;
				LA14: ;
				{
					nimln(80, "bigint.nim");
					carry = 0;
				}
				LA12: ;
			}
			goto LA8;
			LA10: ;
			{
				NI64 TMP141;
				nimln(82, "bigint.nim");
				nimln(82, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				TMP141 = addInt64(((NI64) (a.Digits->data[i])), carry);
				tmp = (NI64)(TMP141);
				nimln(83, "bigint.nim");
				{
					NI64 TMP142;
					nimln(83, "bigint.nim");
					if (!(tmp < 0)) goto LA20;
					nimln(84, "bigint.nim");
					carry = 1;
					nimln(85, "bigint.nim");
					nimln(85, "bigint.nim");
					TMP142 = addInt64(tmp, maxint_84011);
					tmp = (NI64)(TMP142);
				}
				goto LA18;
				LA20: ;
				{
					nimln(87, "bigint.nim");
					carry = 0;
				}
				LA18: ;
			}
			LA8: ;
		}
		goto LA4;
		LA6: ;
		{
			NI64 TMP143;
			nimln(89, "bigint.nim");
			nimln(89, "bigint.nim");
			if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
			TMP143 = addInt64(((NI64) (((NI) (b.Digits->data[i])))), carry);
			tmp = (NI64)(TMP143);
			nimln(90, "bigint.nim");
			{
				NI64 TMP144;
				nimln(90, "bigint.nim");
				if (!(tmp < 0)) goto LA26;
				nimln(91, "bigint.nim");
				carry = 1;
				nimln(92, "bigint.nim");
				nimln(92, "bigint.nim");
				TMP144 = addInt64(tmp, maxint_84011);
				tmp = (NI64)(TMP144);
			}
			goto LA24;
			LA26: ;
			{
				nimln(94, "bigint.nim");
				carry = 0;
			}
			LA24: ;
		}
		LA4: ;
		nimln(95, "bigint.nim");
		digits = (bigintdigits84004*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (tmp));
		nimln(96, "bigint.nim");
		nimln(96, "bigint.nim");
		TMP145 = addInt(i, 1);
		i = (NI64)(TMP145);
	} LA1: ;
	nimln(97, "bigint.nim");
	{
		nimln(97, "bigint.nim");
		if (!(0 < carry)) goto LA31;
		nimln(98, "bigint.nim");
		(*Result).Neg = NIM_TRUE;
	}
	LA31: ;
	nimln(99, "bigint.nim");
	genericSeqAssign(&(*Result).Digits, digits, (&NTI84004));
	popFrame();
}

static N_INLINE(void, initStackBottom)(void) {
	void* volatile locals;
	locals = 0;
	locals = ((void*) (&locals));
	setStackBottom(locals);
}
void PreMain() {
	systemDatInit();
	systemInit();
	bigintDatInit();
	initStackBottom();
}

int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMain)(void) {
	PreMain();
	bigintInit();
}

int main(int argc, char** args, char** env) {
	cmdLine = args;
	cmdCount = argc;
	gEnv = env;
	NimMain();
	return nim_program_result;
}

N_NOINLINE(void, bigintInit)(void) {
	NimStringDesc* LOC1;
	bigint84006 LOC2;
	NimStringDesc* LOC3;
	nimfr("bigint", "bigint.nim")
	nimln(8, "bigint.nim");
	maxint_84011 = 2147483647;
	nimln(10, "bigint.nim");
	nimln(10, "bigint.nim");
	LOC1 = 0;
	LOC1 = nimInt64ToStr(maxint_84011);
	printf("%s\015\012", (LOC1)->data);
	nimln(103, "bigint.nim");
	chckNil((void*)&a_84347);
	genericReset((void*)&a_84347, (&NTI84006));
	initbigint_84017(((NU32) 2), &a_84347);
	nimln(104, "bigint.nim");
	chckNil((void*)&b_84350);
	genericReset((void*)&b_84350, (&NTI84006));
	initbigint_84017(((NU32) 10), &b_84350);
	nimln(107, "bigint.nim");
	nimln(107, "bigint.nim");
	memset((void*)&LOC2, 0, sizeof(LOC2));
	invert_84042(a_84347, &LOC2);
	chckNil((void*)&c_84353);
	genericReset((void*)&c_84353, (&NTI84006));
	HEX2B_84233(b_84350, LOC2, &c_84353);
	nimln(108, "bigint.nim");
	nimln(108, "bigint.nim");
	LOC3 = 0;
	LOC3 = HEX24_84358(c_84353.Digits);
	printf("%s\015\012", (LOC3)->data);
	popFrame();
}

N_NOINLINE(void, bigintDatInit)(void) {
static TNimNode* TMP126[2];
static TNimNode TMP123[3];
NTI84004.size = sizeof(bigintdigits84004*);
NTI84004.kind = 24;
NTI84004.base = (&NTI122);
NTI84004.flags = 2;
NTI84004.marker = TMP125;
NTI84006.size = sizeof(bigint84006);
NTI84006.kind = 18;
NTI84006.base = 0;
NTI84006.flags = 2;
TMP126[0] = &TMP123[1];
TMP123[1].kind = 1;
TMP123[1].offset = offsetof(bigint84006, Digits);
TMP123[1].typ = (&NTI84004);
TMP123[1].name = "digits";
TMP126[1] = &TMP123[2];
TMP123[2].kind = 1;
TMP123[2].offset = offsetof(bigint84006, Neg);
TMP123[2].typ = (&NTI134);
TMP123[2].name = "neg";
TMP123[0].len = 2; TMP123[0].kind = 2; TMP123[0].sons = &TMP126[0];
NTI84006.node = &TMP123[0];
}

