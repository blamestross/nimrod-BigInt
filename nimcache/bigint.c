/* Generated by Nimrod Compiler v0.9.4 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   "C:\Program Files (x86)\Nimrod\dist\mingw\bin\gcc.exe" -c  -w  -I"C:\Program Files (x86)\Nimrod\lib" -o c:\users\brnedan\documents\github\nimrod-bigint\nimcache\bigint.o c:\users\brnedan\documents\github\nimrod-bigint\nimcache\bigint.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct bigint84008 bigint84008;
typedef struct bigintdigits84006 bigintdigits84006;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  bigint84008  {
bigintdigits84006* Digits;
NIM_BOOL Neg;
};
typedef N_NIMCALL_PTR(void, TY2289) (void* p, NI op);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2289 marker;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
typedef NU32 TY84038[1];
struct bigintdigits84006 {
  TGenericSeq Sup;
  NU32 data[SEQ_DECL_SIZE];
};
N_NIMCALL(void, initbigint_84018)(NU32 val, bigint84008* Result);
N_NIMCALL(void, TMP127)(void* p, NI op);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(void, genericSeqAssign)(void* dest, void* src_76004, TNimType* mt);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
N_NIMCALL(void, invert_84043)(bigint84008 a, bigint84008* Result);
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
static N_INLINE(NI, subInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
N_NOINLINE(void, raiseIndexError)(void);
N_NIMCALL(NI64, mulInt64)(NI64 a, NI64 b);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(void, HEX2B_84107)(bigint84008 a, bigint84008 b, bigint84008* Result);
static N_INLINE(NI64, addInt64)(NI64 a, NI64 b);
static N_INLINE(NI64, subInt64)(NI64 a, NI64 b);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NIMCALL(void, HEX2D_84258)(bigint84008 a, bigint84008 b, bigint84008* Result);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
NI64 maxint_84013;
extern TNimType NTI122; /* uint32 */
TNimType NTI84006; /* BigIntDigits */
extern TFrame* frameptr_13038;
TNimType NTI84008; /* BigInt */
extern TNimType NTI134; /* bool */
N_NIMCALL(void, TMP127)(void* p, NI op) {
	bigintdigits84006* a;
	NI LOC1;
	a = (bigintdigits84006*)p;
	LOC1 = 0;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_13038;
	frameptr_13038 = s;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_13038 = (*frameptr_13038).prev;
}

N_NIMCALL(void, initbigint_84018)(NU32 val, bigint84008* Result) {
	bigintdigits84006* LOC1;
	TY84038 LOC2;
	nimfr("initBigInt", "bigint.nim")
	nimln(12, "bigint.nim");
	nimln(12, "bigint.nim");
	LOC1 = 0;
	LOC1 = (bigintdigits84006*) newSeq((&NTI84006), 1);
	LOC2[0] = val;
	LOC1->data[0] = LOC2[0];
	genericSeqAssign(&(*Result).Digits, ((bigintdigits84006*) (LOC1)), (&NTI84006));
	nimln(13, "bigint.nim");
	(*Result).Neg = NIM_FALSE;
	popFrame();
}

static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, invert_84043)(bigint84008 a, bigint84008* Result) {
	bigintdigits84006* digits;
	NI i;
	NI TMP129;
	nimfr("invert", "bigint.nim")
	nimln(17, "bigint.nim");
	chckNil((void*)Result);
	genericReset((void*)Result, (&NTI84008));
	initbigint_84018(((NU32) 0), Result);
	nimln(18, "bigint.nim");
	nimln(18, "bigint.nim");
	(*Result).Neg = !((*Result).Neg);
	nimln(19, "bigint.nim");
	digits = (bigintdigits84006*) newSeq((&NTI84006), 0);
	nimln(20, "bigint.nim");
	nimln(20, "bigint.nim");
	nimln(20, "bigint.nim");
	TMP129 = subInt(a.Digits->Sup.len, 1);
	i = (NI64)(TMP129);
	nimln(21, "bigint.nim");
	while (1) {
		NI64 tmp;
		NI64 TMP130;
		NI TMP131;
		nimln(21, "bigint.nim");
		if (!(0 <= i)) goto LA1;
		nimln(22, "bigint.nim");
		if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
		tmp = ((NI64) (a.Digits->data[i]));
		nimln(23, "bigint.nim");
		nimln(23, "bigint.nim");
		TMP130 = mulInt64(tmp, -1);
		tmp = (NI64)(TMP130);
		nimln(24, "bigint.nim");
		digits = (bigintdigits84006*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (tmp));
		nimln(25, "bigint.nim");
		nimln(25, "bigint.nim");
		TMP131 = subInt(i, 1);
		i = (NI64)(TMP131);
	} LA1: ;
	nimln(26, "bigint.nim");
	genericSeqAssign(&(*Result).Digits, digits, (&NTI84006));
	popFrame();
}

static N_INLINE(NI64, addInt64)(NI64 a, NI64 b) {
	NI64 result;
	result = 0;
	result = (NI64)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI64)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI64)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

static N_INLINE(NI64, subInt64)(NI64 a, NI64 b) {
	NI64 result;
	result = 0;
	result = (NI64)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI64)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI64)(result ^ (NI64)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}
	LA5: ;
	raiseOverflow();
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, HEX2B_84107)(bigint84008 a, bigint84008 b, bigint84008* Result) {
	bigintdigits84006* digits;
	NI i;
	NI64 carry;
	nimfr("+", "bigint.nim")
	nimln(30, "bigint.nim");
	chckNil((void*)Result);
	genericReset((void*)Result, (&NTI84008));
	initbigint_84018(((NU32) 0), Result);
	nimln(31, "bigint.nim");
	digits = (bigintdigits84006*) newSeq((&NTI84006), 0);
	nimln(32, "bigint.nim");
	i = 0;
	nimln(33, "bigint.nim");
	carry = 0;
	nimln(34, "bigint.nim");
	while (1) {
		NIM_BOOL LOC2;
		NI64 tmp;
		NI TMP139;
		nimln(34, "bigint.nim");
		LOC2 = 0;
		nimln(34, "bigint.nim");
		nimln(34, "bigint.nim");
		LOC2 = (i < a.Digits->Sup.len);
		if (LOC2) goto LA3;
		nimln(34, "bigint.nim");
		nimln(34, "bigint.nim");
		LOC2 = (i < b.Digits->Sup.len);
		LA3: ;
		if (!LOC2) goto LA1;
		tmp = 0;
		nimln(36, "bigint.nim");
		{
			nimln(36, "bigint.nim");
			nimln(36, "bigint.nim");
			if (!(i < a.Digits->Sup.len)) goto LA6;
			nimln(37, "bigint.nim");
			{
				NI64 TMP132;
				NI64 TMP133;
				nimln(37, "bigint.nim");
				nimln(37, "bigint.nim");
				if (!(i < b.Digits->Sup.len)) goto LA10;
				nimln(38, "bigint.nim");
				nimln(38, "bigint.nim");
				nimln(38, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
				TMP132 = addInt64(((NI64) (a.Digits->data[i])), ((NI64) (b.Digits->data[i])));
				TMP133 = addInt64((NI64)(TMP132), carry);
				tmp = (NI64)(TMP133);
				nimln(39, "bigint.nim");
				{
					NI64 TMP134;
					nimln(39, "bigint.nim");
					if (!(maxint_84013 < tmp)) goto LA14;
					nimln(40, "bigint.nim");
					carry = 1;
					nimln(41, "bigint.nim");
					nimln(41, "bigint.nim");
					TMP134 = subInt64(tmp, maxint_84013);
					tmp = (NI64)(TMP134);
				}
				goto LA12;
				LA14: ;
				{
					nimln(43, "bigint.nim");
					carry = 0;
				}
				LA12: ;
			}
			goto LA8;
			LA10: ;
			{
				NI64 TMP135;
				nimln(45, "bigint.nim");
				nimln(45, "bigint.nim");
				if ((NU)(i) >= (NU)(a.Digits->Sup.len)) raiseIndexError();
				TMP135 = addInt64(((NI64) (a.Digits->data[i])), carry);
				tmp = (NI64)(TMP135);
				nimln(46, "bigint.nim");
				{
					NI64 TMP136;
					nimln(46, "bigint.nim");
					if (!(maxint_84013 < tmp)) goto LA20;
					nimln(47, "bigint.nim");
					carry = 1;
					nimln(48, "bigint.nim");
					nimln(48, "bigint.nim");
					TMP136 = subInt64(tmp, maxint_84013);
					tmp = (NI64)(TMP136);
				}
				goto LA18;
				LA20: ;
				{
					nimln(50, "bigint.nim");
					carry = 0;
				}
				LA18: ;
			}
			LA8: ;
		}
		goto LA4;
		LA6: ;
		{
			NI64 TMP137;
			nimln(52, "bigint.nim");
			nimln(52, "bigint.nim");
			if ((NU)(i) >= (NU)(b.Digits->Sup.len)) raiseIndexError();
			TMP137 = addInt64(((NI64) (((NI) (b.Digits->data[i])))), carry);
			tmp = (NI64)(TMP137);
			nimln(53, "bigint.nim");
			{
				NI64 TMP138;
				nimln(53, "bigint.nim");
				if (!(maxint_84013 < tmp)) goto LA26;
				nimln(54, "bigint.nim");
				carry = 1;
				nimln(55, "bigint.nim");
				nimln(55, "bigint.nim");
				TMP138 = subInt64(tmp, maxint_84013);
				tmp = (NI64)(TMP138);
			}
			goto LA24;
			LA26: ;
			{
				nimln(57, "bigint.nim");
				carry = 0;
			}
			LA24: ;
		}
		LA4: ;
		nimln(58, "bigint.nim");
		digits = (bigintdigits84006*) incrSeq(&(digits)->Sup, sizeof(NU32));
		digits->data[digits->Sup.len-1] = ((NU32) (tmp));
		nimln(59, "bigint.nim");
		nimln(59, "bigint.nim");
		TMP139 = addInt(i, 1);
		i = (NI64)(TMP139);
	} LA1: ;
	nimln(60, "bigint.nim");
	{
		NIM_BOOL LOC31;
		nimln(60, "bigint.nim");
		LOC31 = 0;
		nimln(60, "bigint.nim");
		LOC31 = !(a.Neg);
		if (!(LOC31)) goto LA32;
		nimln(60, "bigint.nim");
		LOC31 = !(b.Neg);
		LA32: ;
		if (!LOC31) goto LA33;
		nimln(61, "bigint.nim");
		(*Result).Neg = NIM_FALSE;
		nimln(62, "bigint.nim");
		{
			nimln(62, "bigint.nim");
			if (!(0 < carry)) goto LA37;
			nimln(63, "bigint.nim");
			digits = (bigintdigits84006*) incrSeq(&(digits)->Sup, sizeof(NU32));
			digits->data[digits->Sup.len-1] = ((NU32) (carry));
		}
		LA37: ;
	}
	goto LA29;
	LA33: ;
	{
		NIM_BOOL LOC40;
		nimln(64, "bigint.nim");
		LOC40 = 0;
		LOC40 = a.Neg;
		if (!(LOC40)) goto LA41;
		LOC40 = b.Neg;
		LA41: ;
		if (!LOC40) goto LA42;
		nimln(65, "bigint.nim");
		(*Result).Neg = NIM_TRUE;
		nimln(66, "bigint.nim");
		{
			NI64 TMP140;
			nimln(66, "bigint.nim");
			if (!(0 < carry)) goto LA46;
			nimln(67, "bigint.nim");
			nimln(67, "bigint.nim");
			TMP140 = subInt64(maxint_84013, carry);
			digits = (bigintdigits84006*) incrSeq(&(digits)->Sup, sizeof(NU32));
			digits->data[digits->Sup.len-1] = ((NU32) ((NI64)(TMP140)));
		}
		LA46: ;
	}
	goto LA29;
	LA42: ;
	{
		nimln(69, "bigint.nim");
		{
			nimln(69, "bigint.nim");
			if (!(0 < carry)) goto LA51;
			nimln(70, "bigint.nim");
			(*Result).Neg = NIM_TRUE;
		}
		goto LA49;
		LA51: ;
		{
			nimln(72, "bigint.nim");
			(*Result).Neg = NIM_FALSE;
		}
		LA49: ;
	}
	LA29: ;
	nimln(74, "bigint.nim");
	genericSeqAssign(&(*Result).Digits, digits, (&NTI84006));
	popFrame();
}

N_NIMCALL(void, HEX2D_84258)(bigint84008 a, bigint84008 b, bigint84008* Result) {
	bigint84008 LOC1;
	bigint84008 LOC2;
	nimfr("-", "bigint.nim")
	nimln(77, "bigint.nim");
	nimln(77, "bigint.nim");
	memset((void*)&LOC1, 0, sizeof(LOC1));
	invert_84043(b, &LOC1);
	memset((void*)&LOC2, 0, sizeof(LOC2));
	HEX2B_84107(a, LOC1, &LOC2);
	unsureAsgnRef((void**) &(*Result).Digits, LOC2.Digits);
	(*Result).Neg = LOC2.Neg;
	popFrame();
}
N_NOINLINE(void, bigintInit)(void) {
	nimfr("bigint", "bigint.nim")
	nimln(8, "bigint.nim");
	maxint_84013 = 2147483647;
	popFrame();
}

N_NOINLINE(void, bigintDatInit)(void) {
static TNimNode* TMP128[2];
static TNimNode TMP125[3];
NTI84006.size = sizeof(bigintdigits84006*);
NTI84006.kind = 24;
NTI84006.base = (&NTI122);
NTI84006.flags = 2;
NTI84006.marker = TMP127;
NTI84008.size = sizeof(bigint84008);
NTI84008.kind = 18;
NTI84008.base = 0;
NTI84008.flags = 2;
TMP128[0] = &TMP125[1];
TMP125[1].kind = 1;
TMP125[1].offset = offsetof(bigint84008, Digits);
TMP125[1].typ = (&NTI84006);
TMP125[1].name = "digits";
TMP128[1] = &TMP125[2];
TMP125[2].kind = 1;
TMP125[2].offset = offsetof(bigint84008, Neg);
TMP125[2].typ = (&NTI134);
TMP125[2].name = "neg";
TMP125[0].len = 2; TMP125[0].kind = 2; TMP125[0].sons = &TMP128[0];
NTI84008.node = &TMP125[0];
}

